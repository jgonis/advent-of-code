(in-package :aoc-utils)
(defgeneric is-prime? (num))
(defmethod is-prime? ((num integer))
  (cond ((= num 2) t)
        ((= num 3) t)
        (t (let ((end (ceiling (sqrt num))))
             (do ((current 2 (1+ current)))
                 ((> current end) t)
               (if (= 0 (mod num current))
                   (return nil)))))))

(defun generate-prime-list-of-size (number-of-primes)
  (let ((prime-list (list)))
    (do ((current 2 (1+ current)))
        ((= (length prime-list) number-of-primes) (reverse prime-list))
      (if (is-prime? current) 
          (setf prime-list (cons current prime-list))))))

(defun generate-prime-list-up-to (limit)
  (let ((prime-list (list)))
    (do ((current 2 (1+ current)))
        ((> current limit) (reverse prime-list))
      (if (is-prime? current) 
          (setf prime-list (cons current prime-list))))))


(defgeneric generate-next-prime (starting-from))
(defmethod generate-next-prime ((starting-from integer))
  (do ((current (+ starting-from 1) (1+ current)))
      ((is-prime? current) current)))

(defgeneric generate-prime-factor-list (integer-to-factor))
(defmethod generate-prime-factor-list ((integer-to-factor integer))
  (let ((prime-list (generate-prime-list-up-to (ceiling (sqrt integer-to-factor))))
        (factor-list (list)))
    (do ((start integer-to-factor)
         (prime-index 0))
        ((= start 1) (reverse factor-list))
      (cond ((= 0 (mod start (elt prime-list prime-index))) 
             (setf start (/ start (elt prime-list prime-index)))
             (push (elt prime-list prime-index) factor-list)
             (setf prime-index 0))
            (t (setf prime-index (+ prime-index 1)))))))
